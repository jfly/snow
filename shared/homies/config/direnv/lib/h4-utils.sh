# shellcheck shell=bash

### Do not edit. This file was autogenerated by the Honor dev setup scripts: https://github.com/joinhonor/dev-setup-scripts.
use_asdf() {
    source_env "$(asdf direnv envrc "$@")"
}

# This is a version of direnv's `layout_python` that implements option #1
# described in https://github.com/direnv/direnv/issues/1239. See
# https://joinhonor.atlassian.net/browse/FOUND-4939 for more information.

__ensure_symlink() {
    local target=$1
    local name=$2

    if [ -L "$name" ]; then
        local current_target
        current_target=$(readlink "$name")
        if [ "$current_target" = "$target" ]; then
            # The existing symlink is up to date, great! Nothing to do.
            return
        else
            # The existing symlink is out of date. Delete it, and fall through
            # to the code to create a symlink below.
            rm "$name"
        fi
    elif [ -d "$name" ]; then
        # This is probably just an old venv created before this workaround for
        # https://github.com/direnv/direnv/issues/1239. Just delete it.
        rm -r "$name"
    elif [ -e "$name" ]; then
        echo "I'm not sure what's going on with $name" >/dev/stderr
        echo "Out of an abundance of caution, I'm going to abort." >/dev/stderr
        echo "To remove it and try again, try something like 'rm -r $name && direnv reload'" >/dev/stderr
        exit 1
    fi

    ln -s "$target" "$name"
}

layout_python() {
    local old_env
    local python=${1:-python}
    [[ $# -gt 0 ]] && shift
    old_env=$(direnv_layout_dir)/virtualenv
    unset PYTHONHOME
    if [[ -d $old_env && $python == python ]]; then
        VIRTUAL_ENV=$old_env
    else
        local python_full_version ve
        # shellcheck disable=SC2046
        read -r python_full_version python_major_version ve <<<$($python -c "import pkgutil as u, platform as p;ve='venv' if u.find_loader('venv') else ('virtualenv' if u.find_loader('virtualenv') else '');full=p.python_version();major='.'.join(p.python_version_tuple()[:2]);print(full+' '+major+' '+ve)")
        if [[ -z $python_full_version ]]; then
            log_error "Could not find python's version"
            return 1
        fi

        if [[ -n ${VIRTUAL_ENV:-} ]]; then
            local REPLY
            realpath.absolute "$VIRTUAL_ENV"
            VIRTUAL_ENV=$REPLY
            VIRTUAL_ENV_ALT_NAME=""
        else
            VIRTUAL_ENV=$(direnv_layout_dir)/python-$python_full_version
            VIRTUAL_ENV_ALT_NAME=$(direnv_layout_dir)/python-$python_major_version
        fi
        case $ve in
            "venv")
                if [[ ! -d $VIRTUAL_ENV ]]; then
                    $python -m venv "$@" "$VIRTUAL_ENV"
                fi
                ;;
            "virtualenv")
                if [[ ! -d $VIRTUAL_ENV ]]; then
                    $python -m virtualenv "$@" "$VIRTUAL_ENV"
                fi
                ;;
            *)
                log_error "Error: neither venv nor virtualenv are available."
                return 1
                ;;
        esac

        if [ -n "$VIRTUAL_ENV_ALT_NAME" ]; then
            __ensure_symlink "$VIRTUAL_ENV" "$VIRTUAL_ENV_ALT_NAME"
        fi
    fi

    # Create a .venv symlink at the root. This helps some editors (specifically
    # PyCharm) automatically discover the virtual environment.
    __ensure_symlink "$VIRTUAL_ENV" "$PWD/.venv"

    export VIRTUAL_ENV
    PATH_add "$VIRTUAL_ENV/bin"
}

# Import the `wrap_program` helper from direnv-unstdlib.
source_url "https://raw.githubusercontent.com/jfly/direnv-unstdlib/v1.0.1/make-wrapper.sh" "sha256-sz5VdoGrFjiemk0MLAF85nlDo2wleJ/0LiSJ0LXIdDc="

wrap_with_codeartifact_login() {
    local command=$1
    local tool_specific_args=$2

    # shellcheck disable=SC2016 # we are intentionally using single quotes so we can gerate bash code (:scream:)
    wrap_program "$(which "$command")" --run '
# Wrapper for '"$command"' that first authenticates with AWS CodeArtifact.
# See https://joinhonor.atlassian.net/browse/FOUND-4904 for details.

if [ -n "${H4_AUTHENTICATING_WITH_CODEARTIFACT:-}" ]; then
    # Calling `aws codeartifact login` can result in a call to something like
    # `npm config set`, but we may be wrapping npm itself, which would result
    # in an infinite recursion. So, we first set the
    # `H4_AUTHENTICATING_WITH_CODEARTIFACT` environment variable as an
    # indicator of if we are currently authenticating with AWS. If we are, just
    # invoke the original unwrapped tool.
    echo "Skipping AWS CodeArtifact authentication as we appear to already be authenticating." >/dev/stderr
else
    echo "Refreshing AWS CodeArtifact authentication." >/dev/stderr
    export H4_AUTHENTICATING_WITH_CODEARTIFACT=1

    # Note: we direct *all* output from this command to stderr. We are very
    # careful to not print anything to stdout in this wrapper because we do not
    # want to break anyone doing any clever parsing of output from these tools
    # (such as parsing `npm --version`).
    #
	# Note: ecr-local is (now) poorly named as we use it for both pulling docker
	# images *and* pulling packages: https://joinhonor.atlassian.net/browse/FOUND-4826
    (
        # We cd into the home directory as a workaround for
        # https://github.com/aws/aws-cli/issues/8555. This is safe: we do not
        # want this to be a project specific thing, we just want to update the
        # `~/.npmrc` file.
        cd ~
        AWS_PROFILE=ecr-local aws codeartifact login --domain honorcare --repository honorcare-prod --domain-owner 900965112463 --region us-west-2 '"$tool_specific_args"' 1>&2
    )
    unset H4_AUTHENTICATING_WITH_CODEARTIFACT
fi
'
}
